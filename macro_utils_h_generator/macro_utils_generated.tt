<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".h" #>
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

/*THIS FILE IS GENERATED*/
/*DO NOT EDIT BY HAND!!!*/
/*instead edit macro_utils_generated.tt here: http://www.github.com/azure/macro-utils-c.git */

<#/*CHANGE BELOW 2 VARIABLES TO GET MORE / LESS */ #>
<#int nArithmetic=2048;#>
<#int nMacroParameters=140;
    /*127 parameters in one macro definition in C99 in chapter 5.2.4.1 Translation limits*/
    /* 11 Apr 2023: VS 17.5.3 doesn't have a limit of 127 (compiler version is 19.35.32216.1), updating to 140 to allow upstream projects to use more parameters. Note: use sensible increments, compilation time suffers!*/
#>

#ifndef MACRO_UTILS_GENERATED_H
#define MACRO_UTILS_GENERATED_H

#define MU_C2INTERNAL_(x,y) x##y
#define MU_C2INTERNAL(x,y) MU_C2INTERNAL_(x,y)

#define MU_IFCOMMA(N) MU_C2(MU_IFCOMMA_, N)
#define MU_IFCOMMA_0
#define MU_IFCOMMA_2
<#for(var i=4;i<=nMacroParameters;i+=2)#>
<#{#>
#define MU_IFCOMMA_<#=i#> ,
<#}#>

#define MU_IFCOMMALOGIC(N) MU_C2(MU_IFCOMMALOGIC_, N)
#define MU_IFCOMMALOGIC_0
<#for(var i=1;i<=nMacroParameters;i+=1)#>
<#{#>
#define MU_IFCOMMALOGIC_<#=i#> ,
<#}#>

#define MU_IFCOMMA_NOFIRST(N) MU_C2(MU_IFCOMMA_NOFIRST, N)
#define MU_IFCOMMA_NOFIRST1
<#for(var i=2;i<=nMacroParameters;i++)#>
<#{#>
#define MU_IFCOMMA_NOFIRST<#=i#> ,
<#}#>

#define MU_DEC(x) MU_C2(MU_DEC,x)
<#for(var i=nArithmetic;i>=1;i--)#>
<#{#>
#define MU_DEC<#=i#> <#=i-1#>
<#}#>

#define MU_INC(x) MU_C2(MU_INC,x)
<#for(var i=nArithmetic;i>=0;i--)#>
<#{#>
#define MU_INC<#=i#> <#=i+1#>
<#}#>

#define MU_DIV2(x) MU_C2(MU_DIV2_,x)

<#for(var i=nArithmetic;i>=0;i--)#>
<#{#>
#define MU_DIV2_<#=i#> <#=i/2#>
<#}#>

<#/*the below produces MOD2 for numbers*/#>
#define MU_MOD2(x) MU_C2(MU_MOD2_,x)
<#for(var i=nArithmetic;i>=0;i--)#>
<#{#>
#define MU_MOD2_<#=i#> <#=i%2#>
<#}#>

#define MU_THE_NTH_ARG(<#for(var i=1;i<=nMacroParameters;i++)#>
<#{#>P<#=i#>, <#}#> ... ) P<#=nMacroParameters#>

#define MU_COUNT_1_OR_MORE_ARG(...) MU_THE_NTH_ARG (__VA_ARGS__, \
<#for(var i=nMacroParameters-1;i>=1;i--){#><#=i.ToString()+((i>1)?", ":"")#><#}#>)

/*note: F533AD67_7A90_4DC2_A30A_75306900ACE6 is a guid only used here for the purpose of avoiding clashes with other tokens*/
/*the trick here is to insert an EXTRA token (F533AD67_7A90_4DC2_A30A_75306900ACE6), count the __VA_ARGS__ AND this extra token, and then return the number -1*/
#define MU_COUNT_ARG(...) MU_DEC(MU_COUNT_1_OR_MORE_ARG(F533AD67_7A90_4DC2_A30A_75306900ACE6 __VA_OPT__(,) __VA_ARGS__))

/*note: C5942A16_89D5_4732_8BA4_DCD1B9661DB0 is a GUID that is unique for the purpose of avoiding clashes with other tokens*/
/*__VA_OPT__(1A0D532B_BC7E_4F89_9F1F_831A9C6AF51F) expands to exactly the token C5942A16_89D5_4732_8BA4_DCD1B9661DB0 if the __VA_ARGS__ is non-empty*/
#define MU_ISEMPTY(...) MU_IS_EMPTY_IMPL(__VA_OPT__(C5942A16_89D5_4732_8BA4_DCD1B9661DB0))
#define MU_IS_EMPTY_IMPL(x) MU_IS_EMPTY_PICK_##x
#define MU_IS_EMPTY_PICK_ 1                                         /*for the case when __VA_ARGS__ is empty. */
#define MU_IS_EMPTY_PICK_C5942A16_89D5_4732_8BA4_DCD1B9661DB0 0     /*for the case when __VA_ARGS__ is non-empty*/


<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1_<#=i#>(X, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=1;j<=i;j++){#>X(P<#=j#>) <#}#>


<#}#>

<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1A_<#=i#>(X, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=1;j<=i;j++){#>X(P<#=j#>) <#}#>


<#}#>

<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1B_<#=i#>(X, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=1;j<=i;j++){#>X(P<#=j#>) <#}#>


<#}#>

#define MU_FOR_EACH_1(MACRO_TO_INVOKE, ...) MU_C2(MU_FOR_EACH_1_,MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, __VA_ARGS__)
#define MU_FOR_EACH_1A(MACRO_TO_INVOKE, ...) MU_C2(MU_FOR_EACH_1A_,MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, __VA_ARGS__)
#define MU_FOR_EACH_1B(MACRO_TO_INVOKE, ...) MU_C2(MU_FOR_EACH_1B_,MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, __VA_ARGS__)

<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1_PASTE_<#=i#>(PASTE, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=1;j<=i;j++){#>MU_C2INTERNAL(PASTE, P<#=j#>) <#}#>


<#}#>

#define MU_FOR_EACH_1_PASTE(PASTE, ...) MU_C2(MU_FOR_EACH_1_PASTE_,MU_COUNT_ARG(__VA_ARGS__)) ( PASTE, __VA_ARGS__)

<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1_KEEP_1_<#=i#>(X, keep, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+(j<i?", ":"")#><#}#>) \
<#for(var j=1;j<=i;j++){#>X(keep, P<#=j#>) <#}#>


<#}#>

#define MU_FOR_EACH_1_KEEP_1_0(MACRO_TO_INVOKE, ...) /*expands to nothing*/

#define MU_FOR_EACH_1_KEEP_1(MACRO_TO_INVOKE, KEEP, ...) MU_C2(MU_FOR_EACH_1_KEEP_1_, MU_COUNT_ARG(__VA_ARGS__))( MACRO_TO_INVOKE, KEEP, __VA_ARGS__)

<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1_KEEP_2_<#=i#>(X, KEEP1, KEEP2, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+(j<i?", ":"")#><#}#>) \
<#for(var j=1;j<=i;j++){#>X(KEEP1, KEEP2, P<#=j#>) <#}#>


<#}#>

#define MU_FOR_EACH_1_KEEP_2_0(...)

#define MU_FOR_EACH_1_KEEP_2(MACRO_TO_INVOKE, KEEP1, KEEP2, ...) MU_C2(MU_FOR_EACH_1_KEEP_2_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, KEEP1, KEEP2, __VA_ARGS__)

<#for(var i=nMacroParameters;i>=2;i-=2)#>
<#{#>
#define MU_FOR_EACH_2_KEEP_1_<#=i#>(X, KEEP, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+(j<i?", ":"")#><#}#>) \
<#for(var j=i;j>=2;j-=2){#>X(KEEP, P<#=i-j+1#>, P<#=i-j+2#>) <#}#>


<#}#>

#define MU_FOR_EACH_2_KEEP_1_1(...)

#define MU_FOR_EACH_2_KEEP_1_0(...)

#define MU_FOR_EACH_2_KEEP_1(MACRO_TO_INVOKE, KEEP, ...) MU_C2(MU_FOR_EACH_2_KEEP_1_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, KEEP, __VA_ARGS__)


<#for(var i=nMacroParameters;i>=2;i-=2)#>
<#{#>
#define MU_FOR_EACH_2_KEEP_2_<#=i#>(X, KEEP1, KEEP2, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+(j<i?", ":"")#><#}#>) \
<#for(var j=i;j>=2;j-=2){#>X(KEEP1, KEEP2, P<#=i-j+1#>, P<#=i-j+2#>) <#}#>


<#}#>

#define MU_FOR_EACH_2_KEEP_2_1(...)

#define MU_FOR_EACH_2_KEEP_2_0(...)

#define MU_FOR_EACH_2_KEEP_2(MACRO_TO_INVOKE, KEEP1, KEEP2, ...) MU_C2(MU_FOR_EACH_2_KEEP_2_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, KEEP1, KEEP2, __VA_ARGS__)


<#for(var i=nMacroParameters;i>=2;i-=2)#>
<#{#>
#define MU_FOR_EACH_2_<#=i#>(X, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=i;j>=2;j-=2){#>X(P<#=i-j+1#>, P<#=i-j+2#>) <#}#>


<#}#>

#define MU_FOR_EACH_2_0(...)

#define MU_FOR_EACH_2(MACRO_TO_INVOKE, ...) MU_C2(MU_FOR_EACH_2_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, __VA_ARGS__)




<#for(var i=nMacroParameters;i>=2;i-=2)#>
<#{#>
#define MU_FOR_EACH_2_REVERSE_<#=i#>(X, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=i;j>=2;j-=2){#>X(P<#=j-1#>, P<#=j#>) <#}#>


<#}#>

#define MU_FOR_EACH_2_REVERSE_0(...)

#define MU_FOR_EACH_2_REVERSE(MACRO_TO_INVOKE, ...) MU_C2(MU_FOR_EACH_2_REVERSE_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, __VA_ARGS__)


<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1_COUNTED_<#=i#>(X, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=i;j>=1;j--){#>X(<#=j#>, P<#=i-j+1#>) <#}#>


<#}#>

#define MU_FOR_EACH_1_COUNTED_0(...)

#define MU_FOR_EACH_1_COUNTED(MACRO_TO_INVOKE, ...) MU_C2(MU_FOR_EACH_1_COUNTED_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE,  __VA_ARGS__)



<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1_KEEP_2_COUNTED_<#=i#>(X, KEEP1, KEEP2, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=i;j>=1;j--){#>X(<#=j#>, KEEP1, KEEP2, P<#=i-j+1#>) <#}#>


<#}#>

#define MU_FOR_EACH_1_KEEP_2_COUNTED_0(...)

#define MU_FOR_EACH_1_KEEP_2_COUNTED(MACRO_TO_INVOKE, KEEP1, KEEP2, ...) MU_C2(MU_FOR_EACH_1_KEEP_2_COUNTED_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, KEEP1, KEEP2, __VA_ARGS__)



<#for(var i=nMacroParameters;i>=1;i--)#>
<#{#>
#define MU_FOR_EACH_1_KEEP_1_COUNTED_<#=i#>(X, KEEP, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=i;j>=1;j--){#>X(<#=j#>, KEEP, P<#=i-j+1#>) <#}#>


<#}#>

#define MU_FOR_EACH_1_KEEP_1_COUNTED_0(...)

#define MU_FOR_EACH_1_KEEP_1_COUNTED(MACRO_TO_INVOKE, KEEP, ...) MU_C2(MU_FOR_EACH_1_KEEP_1_COUNTED_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE, KEEP, __VA_ARGS__)




<#for(var i=nMacroParameters;i>=2;i-=2)#>
<#{#>
#define MU_FOR_EACH_2_COUNTED_<#=i#>(X, <#for(var j=1;j<=i;j++){#>P<#=j.ToString()+((j<i)?", ":"")#><#}#>) \
<#for(var j=i;j>=1;j-=2){#>X(<#=j#>, P<#=i-j+1#>, P<#=i-j+2#>) <#}#>


<#}#>

#define MU_FOR_EACH_2_COUNTED_0(...)

/*the COUNTED breed of MU_FOR_EACH macro invokes a macro with 3 parameters: 1st being the count of invocation. For example.
MU_FOR_EACH_2_COUNTED(MACRO, a,b,c,d,e,f) will result in
MACRO(6, a,b)
MACRO(4, c,d)
MACRO(2, e,f)
This macro exists because we need a "stop condition" in outputting COMMA... when calling a function f(a,b,c,d) cannot be f(a,b,c,d,) <=doesn't compile (as opposed to enum definition)
*/
/*MU_FOR_EACH_2_REVERSE acts just like MU_FOR_EACH_2, but in reverse order. Example:
MU_FOR_EACH_2_REVERSE(X,a,b,c,d,e,f) => X(e,f) X(c,d) X (a, b) in this order */


#define MU_FOR_EACH_2_COUNTED(MACRO_TO_INVOKE, ...) MU_C2(MU_FOR_EACH_2_COUNTED_, MU_COUNT_ARG(__VA_ARGS__)) ( MACRO_TO_INVOKE,  __VA_ARGS__)

<#for(var i=nMacroParameters;i>=0;i--){#>
#define MU_DO_<#=i#>(MACRO, ...) \
<#for(var j=i;j>=0;j--){#>MACRO(<#=j#>, __VA_ARGS__) <#}#>


<#}#>

#define MU_DO(TIMES, MACRO, ...) MU_C2(MU_DO_, TIMES)(MACRO, __VA_ARGS__)

#endif /*MACRO_UTILS_GENERATED_H*/
